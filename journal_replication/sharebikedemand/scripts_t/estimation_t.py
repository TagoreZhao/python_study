# We will need to load all libraries here
import numpy as np

#test code to see if this is actually executable
#print("Hello World")

# We start with section 5.1, we need define functions that will help us generate the synthetic data.

#We first need figure out what parameters we are gonna need and output.
#We need to specify the input and output
'''
Input:
    Arrival locations are generated uniformly within the range [-0.8*loc_bound, 0.8*loc_bound].
    rand_seed: random seed
    num_position: total number of arrival locations
    bike_num: total number of bikes
    grid_size: grid size of the candidate location
    beta0, beta1_true: MNL model parameter
    loc_bound: bound of the bike locations and arrival locations
    split_data: whether split the data into train/test set

    
Variable Inbetween:
    dist_i:
    The index of the distance between the arrived rider and the bike. (not including the riders that have not booked a bike)

    xi,yi:
    The coordinates of the destination of the rider.

    dist[:,dist_i,int(book_bike[num_booked])]:
    This will return the distance bewttween the booked bike and all the arrival locations.

Output:
    bike_num: total number of bikes
    num_records: dist.shape[1]
    book_bike: array of length num_booked. Contains a squence of booking bikes.
    book_index: The index of rider that booked the bike.
    dist: 
        this is a matrix of dimension num_position * num_records * bike_num, it returns the distance between each
        arrival location and bike location.
    bike_loc: 
        this is a matrix of dimension num_position * bike_num *2, it returns the bike location at each time period(rider arrival).
    all_period:
        array of length num_records, return the duration of each trip.
    num_booked:
        total number of bikes that are booked = total number of rider that booked a bike.
    cand_loc:
        matrix of size 1*grid_size^2*2, it returns the coordinates of all candidate locations.
    true_loc:
        matrix of size num_position*2, it returns the coordinates of all arrival locations.
    position_weight:
        array of length num_position, it returns the weight of each arrival location. This is generated by a uniform distribution and normalized to sum to 1.
'''

def gen_sync(rand_seed,num_position,bike_num,lambd,grid_size,beta0=1,beta1_true=-1,T=50,loc_bound=5):

    #set the random seed.
    np.random.seed(rand_seed)

    #generate the candidate locations
    cand_loc = gen_loc(loc_bound,grid_size,s=1.25)
    # I do not understand why do we need a scale parameter here instead of just using loc_bound directly.
    posx = np.random.uniform(-4*loc_bound/5,4*loc_bound/5,num_position)
    posy = np.random.uniform(-4*loc_bound/5,4*loc_bound/5,num_position)
    true_loc = np.stack((posx,posy),axis=1)

    #we need to sample a sequence of arrivals based on a homogeneous poisson process with rate lambd in interval [0,T].
    num_records = np.random.poisson(lambd*T,1)[0]
    arr_time = np.random.uniform(0, T, num_records)
    arr_time = np.sort(arr_time)

    #we will tot_time to store the total time of the simulation.(both begin time and finish time)
    tot_time = arr_time.copy()
    tot_time = np.append(tot_time, T)

    #we sample a list of parameters for the MNL model.
    location_weight = np.random.uniform(0,1,num_position)
    location_weight = location_weight/np.sum(location_weight)

    #we need to know the index of riders arrival location.
    ridgenpos = np.argmax(np.random.multinomial(1,location_weight,size=num_records),axis=1)

    #we now sample initial bike locations
    bike_loc = np.zeros((1,bike_num,2))
    for i in range(bike_num):
        bike_loc[0,i,0] = np.random.uniform(-loc_bound,loc_bound)
        bike_loc[0,i,1] = np.random.uniform(-loc_bound,loc_bound)

    #we need to compute the distance between the initial arrival location and the bike location.
    # Initialize the distance list with initial distances
    dist_list = []
    initial_dist = np.zeros((num_position, bike_num))
    for i in range(num_position):
        for j in range(bike_num):
            initial_dist[i, j] = np.linalg.norm(true_loc[i, :] - bike_loc[0, j, :])
    dist_list.append(initial_dist)

    #We now need to simulate the booking process.
    book_bike = []
    book_index = []
    all_period = []
    num_booked = 0
    
    for t in range(num_records):
        genpos = ridgenpos[t]
        dist_cur = dist_list[-1].copy()
        #print(genpos)
        # Compute the probability of booking using the MNL model
        prob_leave = findprob0(dist_cur, genpos, beta0, beta1_true)

        if not np.random.binomial(1, prob_leave):
            closest_bike = np.argmin(dist_cur[genpos, :])
            book_bike.append(closest_bike)
            book_index.append(t)
            num_booked += 1

        # Randomly sample destination uniformly within [-loc_bound, loc_bound]Â²
            dest_x = np.random.uniform(-loc_bound, loc_bound)
            dest_y = np.random.uniform(-loc_bound, loc_bound)

        # Compute walking time and traveling time
            walking_time = dist_cur[genpos, closest_bike] / 4
            traveling_time = np.linalg.norm([dest_x, dest_y] - bike_loc[0, closest_bike, :]) / 18

            # Compute the duration of the trip
            duration = np.maximum(np.random.normal(walking_time + traveling_time, 0.1), 0.05)
            all_period.append(duration)

            # Update bike location after trip
            bike_loc[0, closest_bike, :] = [dest_x, dest_y]

            # Update distances for next arrivals
            new_dist = np.zeros((num_position, bike_num))
            for i in range(num_position):
                for j in range(bike_num):
                    new_dist[i, j] = np.linalg.norm(true_loc[i, :] - bike_loc[0, j, :])
            
            dist_list.append(new_dist)
    dist = np.stack(dist_list, axis=1)
    return(bike_num,num_records,np.array(book_bike),np.array(book_index),dist,bike_loc,np.array(all_period),num_booked,cand_loc,true_loc,location_weight)

'''
    This function is used to generate the location of the bike and arrival locations.
    Input:
        Generate a Cartesian grid of locations.
        loc_bound: location bound (can be a float or an array with four elements)
        s: scale parameter 
        grid_size: size of the grid
        coor: the coordinate of the center of the grid
    Output:
        loc: matrix of size 1*grid_size^2*2, it returns the coordinates of all candidate locations.
        this is a grid with 10 lines and 9 intervals on each side.
'''
def gen_loc(loc_bound,grid_size,s=1,coor=np.zeros(2)):
    npos = grid_size**2
    if isinstance(loc_bound,list):
        a = np.linspace(loc_bound[0]/s+coor[0],loc_bound[1]/s+coor[0],grid_size)
        b = np.linspace(loc_bound[2]/s+coor[1],loc_bound[3]/s+coor[1],grid_size)
    else:
        a = np.linspace(-loc_bound/s+coor[0],loc_bound/s+coor[0],grid_size)
        b = np.linspace(-loc_bound/s+coor[1],loc_bound/s+coor[1],grid_size)
        loc = np.zeros((1,npos,2))
    for i in range(npos):
        loc[0,i,0] = a[int(i/grid_size)]
        loc[0,i,1] = b[int(i%grid_size)]
    return loc

'''
  Return the probability of leaving under the MNL model
  Input:
    dist_cur: the distance between the arrived rider and the bike.
    genpos: the index of the rider's arrival location.
    beta0, beta1_true: MNL model parameter
'''
def findprob0(dist_cur,genpos,beta0,beta1_true):
  return 1/(1+np.sum(np.exp(beta0+beta1_true*dist_cur[genpos,:])))

