# We will need to load all libraries here
import numpy as np

#test code to see if this is actually executable
#print("Hello World")

# We start with section 5.1, we need define functions that will help us generate the synthetic data.

#We first need figure out what parameters we are gonna need and output.
#We need to specify the input and output
def gen_sync(rand_seed,num_position,bike_num,lambd,grid_size,beta0=1,beta1_true=-1,T=50,loc_bound=5,split_data=False):  
    '''
    Input:
        Arrival locations are generated uniformly within the range [-0.8*loc_bound, 0.8*loc_bound].
        rand_seed: random seed
        num_position: total number of arrival locations
        bike_num: total number of bikes
        grid_size: grid size of the candidate location
        beta0, beta1_true: MNL model parameter
        loc_bound: bound of the bike locations and arrival locations
        split_data: whether split the data into train/test set

        
    Variable Inbetween:
        dist_i:
        The index of the distance between the arrived rider and the bike. (not including the riders that have not booked a bike)

        xi,yi:
        The coordinates of the destination of the rider.

        dist[:,dist_i,int(book_bike[num_booked])]:
        This will return the distance bewttween the booked bike and all the arrival locations.

    Output:
        bike_num: total number of bikes
        num_records: dist.shape[1]
        book_bike: array of length num_booked. Contains a squence of booking bikes.
        book_index: The index of rider that booked the bike.
        dist: 
            this is a matrix of dimension num_position * num_records * bike_num, it returns the distance between each
            arrival location and bike location.
        bike_loc: 
            this is a matrix of dimension num_position * bike_num *2, it returns the bike location at each time period(rider arrival).
        all_period:
            array of length num_records, return the duration of each trip.
        num_booked:
            total number of bikes that are booked = total number of rider that booked a bike.
        cand_loc:
            matrix of size 1*grid_size^2*2, it returns the coordinates of all candidate locations.
        true_loc:
            matrix of size num_position*2, it returns the coordinates of all arrival locations.
        position_weight:
            array of length num_position, it returns the weight of each arrival location. This is generated by a uniform distribution and normalized to sum to 1.
    '''
    np.random.seed(seed=rand_seed)
    posx = np.random.uniform(-4*loc_bound/5,4*loc_bound/5,num_position)
    posy = np.random.uniform(-4*loc_bound/5,4*loc_bound/5,num_position)
    true_loc = np.stack((posx,posy),axis=1)

    position_weight = np.random.uniform(0,1,num_position)
    position_weight = position_weight / np.sum(position_weight)

    total_arr = np.random.poisson(lambd*T,size=1)[0]
    arr_time = np.sort(np.random.uniform(0,T,total_arr))
    tot_time = arr_time.copy()
    cand_loc = gen_loc(loc_bound,grid_size,s=1.25)


    book_bike = np.array([],dtype=int)
    x0 = np.random.uniform(0,loc_bound,bike_num)
    y0 = np.random.uniform(0,loc_bound,bike_num)
    dist = np.zeros((num_position,1,bike_num))
    bike_loc = np.zeros((1,bike_num,2))
    for i in range(num_position):
        dist[i,0,:] = np.sqrt((x0-posx[i])**2+(y0-posy[i])**2)
    bike_loc[0,:,:] = np.stack((x0,y0),axis=1)

    book_index_arr = np.array([],dtype=int)
    book_index = np.array([],dtype=int)
    ridgenpos = np.argmax(np.random.multinomial(1,position_weight,size=total_arr),axis=1)
    num_booked = 0
    duration = np.array([])
    book_time = np.array([])
    i = 0
    dist_i = 0
    finish_time = np.array([])
    k1 = 0
    xi = np.array([])
    yi = np.array([])
        
    while (i < tot_time.shape[0]):
        i = i + 1
        if tot_time[i-1] in finish_time:
            dist_i = dist_i + 1
            dist = np.hstack((dist,dist[:,dist_i-1,:].reshape(num_position,1,-1)))
            bike_loc = np.vstack((bike_loc,bike_loc[dist_i-1,:,:].reshape(1,bike_num,2)))
            bike_index = np.where((book_time + duration)==tot_time[i-1])[0][0]
            bike_loc[dist_i,int(book_bike[bike_index]),:] = [xi[bike_index], yi[bike_index]]
            dist[:,dist_i,int(book_bike[bike_index])] = np.sqrt((xi[bike_index]-posx)**2+(yi[bike_index]-posy)**2)
        else:
            k1 = k1 + 1
            prob_leave = findprob0(dist[:,dist_i,:],ridgenpos[k1-1],beta0,beta1_true)
            if not np.random.binomial(1,prob_leave):
                dist_i = dist_i + 1
                dist = np.hstack((dist,dist[:,dist_i-1,:].reshape(num_position,1,-1)))
                bike_loc = np.vstack((bike_loc,bike_loc[dist_i-1,:,:].reshape(1,bike_num,2)))
                
                book_index_arr = np.append(book_index_arr,i-1)
                book_time = np.append(book_time,tot_time[i-1])
                choiceprob = np.exp(beta1_true*dist[ridgenpos[k1-1],dist_i-1,:])/np.sum(np.exp(beta1_true*dist[ridgenpos[k1-1],dist_i-1,:]))
                book_bike = np.append(book_bike,np.argmax(np.random.multinomial(1,choiceprob,size=1)))
                book_index = np.append(book_index,dist_i-1)
                
                dist[:,dist_i,int(book_bike[num_booked])] = np.inf
                bike_loc[dist_i,int(book_bike[num_booked]),:] = [np.inf, np.inf]

                xi = np.append(xi,np.random.uniform(-loc_bound,loc_bound,1)[0])
                yi = np.append(yi,np.random.uniform(-loc_bound,loc_bound,1)[0])
                dist_to_dest = np.sqrt((xi[-1]-posx[ridgenpos[k1-1]])**2+(yi[-1]-posy[ridgenpos[k1-1]])**2)
                dur = np.max([dist_to_dest/18+ dist[ridgenpos[k1-1],dist_i-1,int(book_bike[num_booked])]/4+np.random.normal(0,0.1),0.05])
                duration = np.append(duration,dur)
                finish_time = np.append(finish_time,tot_time[i-1]+dur)
                tot_time = np.sort(np.append(tot_time,tot_time[i-1]+dur))
                book_index_arr[num_booked] = i-1
                num_booked = num_booked + 1
        book_finish_time = np.sort(np.concatenate((book_time,finish_time)))
        all_period = np.append(book_finish_time,[T])-np.append([0],book_finish_time)
        num_records = dist.shape[1]
    if split_data:
        time_portion = 0.8
        book_finish_time_train = book_finish_time[book_finish_time<time_portion*T]
        book_finish_time_test = book_finish_time[book_finish_time>=time_portion*T]
        train_period = np.append(book_finish_time_train,[time_portion*T])-np.append([0],book_finish_time_train)
        test_period = np.append(book_finish_time_test,[T])-np.append([time_portion*T],book_finish_time_test)
        num_records_train = train_period.shape[0]
        num_records_test = test_period.shape[0]
        num_booked_train = book_time[book_time<time_portion*T].shape[0]
        num_booked_test = num_booked-num_booked_train
        
        train_data = [bike_num,num_records_train,book_bike[:num_booked_train],book_index[:num_booked_train],dist[:,:num_records_train,:],
                    bike_loc[:num_records_train,:,:],train_period,num_booked_train,cand_loc,true_loc,position_weight]
        test_data = [bike_num,num_records_test,book_bike[num_booked_train:],book_index[num_booked_train:]-num_records_train+1,dist[:,(num_records_train-1):,:],
                    bike_loc[(num_records_train-1):,:,:],test_period,num_booked_test,cand_loc,true_loc,position_weight]
    
        return (train_data,test_data)
        
    return(bike_num,num_records,book_bike,book_index,dist,bike_loc,all_period,num_booked,cand_loc,true_loc,position_weight)


def gen_loc(loc_bound,grid_size,s=1,coor=np.zeros(2)):
    '''
    This function is used to generate the location of the bike and arrival locations.
    Input:
        Generate a Cartesian grid of locations.
        loc_bound: location bound (can be a float or an array with four elements)
        s: scale parameter 
        grid_size: size of the grid
        coor: the coordinate of the center of the grid
    Output:
        loc: matrix of size 1*grid_size^2*2, it returns the coordinates of all candidate locations.
        this is a grid with 10 lines and 9 intervals on each side.
    '''
    npos = grid_size**2
    if isinstance(loc_bound,list):
        a = np.linspace(loc_bound[0]/s+coor[0],loc_bound[1]/s+coor[0],grid_size)
        b = np.linspace(loc_bound[2]/s+coor[1],loc_bound[3]/s+coor[1],grid_size)
    else:
        a = np.linspace(-loc_bound/s+coor[0],loc_bound/s+coor[0],grid_size)
        b = np.linspace(-loc_bound/s+coor[1],loc_bound/s+coor[1],grid_size)
        loc = np.zeros((1,npos,2))
    for i in range(npos):
        loc[0,i,0] = a[int(i/grid_size)]
        loc[0,i,1] = b[int(i%grid_size)]
    return loc


def findprob0(dist_cur,genpos,beta0,beta1_true):
  '''
  Return the probability of leaving under the MNL model
  Input:
    dist_cur: the distance between the arrived rider and the bike.
    genpos: the index of the rider's arrival location.
    beta0, beta1_true: MNL model parameter
 '''
  return 1/(1+np.sum(np.exp(beta0+beta1_true*dist_cur[genpos,:])))

