# We will need to load all libraries here
import numpy as np

#test code to see if this is actually executable
#print("Hello World")

# We start with section 5.1, we need define functions that will help us generate the synthetic data.

#We first need figure out what parameters we are gonna need and output.
#We need to specify the input and output
'''
Input:
    Arrival locations are generated uniformly within the range [-0.8*loc_bound, 0.8*loc_bound].
    rand_seed: random seed
    num_position: total number of arrival locations
    bike_num: total number of bikes
    grid_size: grid size of the candidate location
    beta0, beta1: MNL model parameter
    loc_bound: bound of the bike locations and arrival locations
    split_data: whether split the data into train/test set

Output:
    bike_num: total number of bikes
    num_records: number of all arrived riders. 
    book_bike: array of length num_booked. Contains a squence of booking bikes.
    book_index: The index of rider that booked the bike.
    dist: 
        this is a matrix of dimension num_position * num_records * bike_num, it returns the distance between each
        arrival location and bike location.
    bike_loc: 
        this is a matrix of dimension num_position * bike_num *2, it returns the bike location at each time period(rider arrival).
    all_period:
        array of length num_records, return the duration of each trip.
    num_booked:
        total number of bikes that are booked = total number of rider that booked a bike.
    cand_loc:
        matrix of size 1*grid_size^2*2, it returns the coordinates of all candidate locations.
    true_loc:
        matrix of size num_position*2, it returns the coordinates of all arrival locations.
    position_weight:
        array of length num_position, it returns the weight of each arrival location. This is generated by a uniform distribution and normalized to sum to 1.
'''

def gen_sync_in_grid(rand_seed,num_position,bike_num,lambd,grid_size,beta0=1,beta1_true=-1,T=50,loc_bound=5):

    #set the random seed.
    np.random.seed(rand_seed)

    #generate the candidate locations
    cand_loc = gen_loc(loc_bound,grid_size)



'''
    This function is used to generate the location of the bike and arrival locations.
    Input:
        Generate a Cartesian grid of locations.
        loc_bound: location bound (can be a float or an array with four elements)
        s: scale parameter 
        grid_size: size of the grid
        coor: the coordinate of the center of the grid
    Output:
        loc: matrix of size 1*grid_size^2*2, it returns the coordinates of all candidate locations.
        this is a grid with 10 lines and 9 intervals on each side.
'''
def gen_loc(loc_bound,grid_size,s=1,coor=np.zeros(2)):
    npos = grid_size**2
    if isinstance(loc_bound,list):
        a = np.linspace(loc_bound[0]/s+coor[0],loc_bound[1]/s+coor[0],grid_size)
        b = np.linspace(loc_bound[2]/s+coor[1],loc_bound[3]/s+coor[1],grid_size)
    else:
        a = np.linspace(-loc_bound/s+coor[0],loc_bound/s+coor[0],grid_size)
        b = np.linspace(-loc_bound/s+coor[1],loc_bound/s+coor[1],grid_size)
        loc = np.zeros((1,npos,2))
    for i in range(npos):
        loc[0,i,0] = a[int(i/grid_size)]
        loc[0,i,1] = b[int(i%grid_size)]
    return loc

